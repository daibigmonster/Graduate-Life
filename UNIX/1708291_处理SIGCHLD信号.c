/*处理SIGCHLD信号
设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息包括子进程的进程ID、终止状态以及资源利用信息。如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理他们呢（也就是说init进程将wait它们从而取出它们的僵死状态）。
处理僵死进程
我们显然不愿意留存僵死进程。它们占用内核中的空间，最终可能导致我们耗尽进程资源。无论何时我们fork子进程都得wait它们，以防止它们编程僵死进程。为此我们建立一个俘获SIGCHLD信息号的信号处理函数，在函数体中我们调用wait.
通过listen调用之后增加如下函数调用：
Signal(SIGCHLD,sig_chld);
我们就建立了信号处理函数*/
#include "unp.h"
void sig_chld(int signo){
	pid_t pid;
	int stat;
	pid=wait(&stat);
	printf("child %d terminated\n",pid);
	return;
}
/*具体各个步骤如下
我们键入EOF字符来终止客户。客户TCP发送一个SIN给服务器，服务器响应一个ACK
收到客户的FIN导致服务器TCP递送一个EOF给子进程阻塞中的的readline，从而子进程终止
既然该信号是在父进程阻塞于慢系统调用(accept)时由父进程捕获的，内核就会使accept返回一个ENTER错误(被中断的系统调用)。而父进程不出里错误，于是中止。
这个例子是为了说明，在编写捕获信号的网络程序时，我么必须人情被中断的系统调用且处理它们。在这个特定例子中，标准C函数库不会使用内核自动重启被中断的系统调用。
也就是说，我们在图5.6中设置的SA_RESTART标识在系统函数库的signal函数中并没有设置。另有些系统自动重启被中断的系统调用。如果我们在4.4BSD环境下照样使用系统库函数版本的signal函数运行上述例子，那么内核将重启被中断的系统调用，于是accept不会返回错误。我们定义自己的signal函数并在全书使用的理由之一就是应对不同操作系统之间存在的这个潜在问题
处理被中断的系统调用
我们用术语慢系统调用描述过acept函数，该函数也适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用使之调用可能永远无法返回，多数网络支持函数都属于这一类
举例来说，如果没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证，类似的如果客户从未发送过一行要求服务器回射的文本，那么服务器的read调用将永不返回。
适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTER错误。有些内核自动重启某些被中断的系统调用。不过为了便于移植，当我们编写捕获信号的程序时（多数并发服务器捕获SIGCHLD），我们必须对慢系统调用返回EINTER有所准备。即使某个实现支持SA_RESTART标识，也并非所有被中断系统调用都可以自动重启。举例来说，大多数原子Berkeley的实现从不自动重启select，其中有些实现从不重启accept和recvfrom.
为了处理被中断的accept,我们把5-2中对accept的调用从for循环开始改起，如下所示：
for(;;){
	chilen=sizeof(cliaddr);
	if((connfd=accept(listenfd,(SA*)&chliaddr,&clilen))<0){
		if(errno==EINTER)continue;
		else err_sys("accept error");
		}
}
注意，我们调用的是accept函数本身而不是它的包裹函数Accept，因为我们必须自己处理该函数的失败情况。
这段代码所做的事情就是自己重启被中断的系统调用，对于accept以及诸如read、write、select和open之类的函数来说这是合适的。不过有一个函数我们不能重启：connect。如果该函数返回EINTER，我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获的信号重端而且不能自动重启时，我们必须调用select来等待连接完成。
