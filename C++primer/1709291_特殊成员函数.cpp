/*
 * StringBad类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就StringBad而言，这些函数的行为与累设计不符。具体地说，C++自动提供了下面这些成员函数
 * 默认构造函数，如果没有定义构造函数：
 * 默认析构函数，如果没有定义
 * 复制构造函数，如果没有定义
 * 赋值运算符，如果没有定义
 * 地址运算符，如果没有定义
 * 更准确地说，编译器讲生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做，例如，如果您将一个对象赋给另一个对象，编译器讲提供赋值运算符的定义
 * 结果表明，StringBad类中的问题是由隐式赋值构造函数和隐式运算符引起的
 * 隐式地址运算符返回调用对象的地址（即this指针的值）。这与我们的初中是一致的，再次不详细讨论该成员函数。默认析构函数不执行任何操作。
 * 如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对他进行初始化，则必须显式地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值：
 * Klunk::Klunk()
 * {
 *     klunk_ct = 0;
 * }
 * 带参数的构造函数也可以书默认构造函数，只有所有参数都有默认值。例如，Klunk类可以包含下属内联构造函数：
 * Klunk(){ klunk_ct = n;}
 * 但只能有一个默认构造函数。也就是说，不能这么做：
 * Klunk() { klunk_ct = 0; }
 * Klunk() ( int n = 0) { klunk_ct = n;}
 * 这为何有二义性呢，
 * Klunk kar(10);
 * Klunk bus;
 * 这样定义明显是错误的
 *
 * 复制构造函数
 * 复制构造函数用于将一个对象赋值到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中。类的赋值构造函数原型通常如下：
 * Class_name(const Class_name &);
 * 它接受一个指向类对象的常量引用作为参数。例如，String类的赋值构造函数的原型如下：
 * StringBad(const StringBad &);
 * 对与赋值构造函数，需要知道两点：何时调用和有何功能。
 *
 * 3何时调用复制构造函数
 * 新建一个对象并将起初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。假设motto是一个StringBad对象，则下面4中声明都将调用赋值构造函数：
 * StringBad ditto(motto);
 * StringBad metoo = motoo;
 * StringBad also = StringBad(motoo);
 * StringBad * pStringBad = new StringBad(motto);
 *其中中间的2个声明可能会使用赋值构造函数直接创建metoo和also，也可能使用赋值构造函数生成一个临时对象，然后将临时对象的内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto初始化一个匿名对象，并将新对象的地址赋给pstring指针。
 *每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数传递对象或函数返回对象时，都将使用赋值构造函数，记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。例如，将3个Vector对象相加时，编译器可能生成临时的Vector对象保存中间结果。何时生成临时对象随编译器而异，但无论那种编译器，当按值传递和返回对象时，都将调用复制构造函数：
 callme2(headline2);

 *
 * 12.1.4Stringbad的其他问题：赋值运算符 
 * 并不是程序清单12.3的所有问题都可以归咎于默认的赋值构造函数，还需要看一看默认的赋值运算符。ANSI C允许机构赋值，而C++允许对象赋值，这是通过自动为类重载赋值运算符实现的，这种运算符的原型如下：
 * Class_name & Class_name::operator = (const Class_name &);
 * 它接受并返回一个指向类对象的引用。例如,StringBad类的赋值运算符的原型如下：
 * StringBad & String id::operator = (const StringBad &)
 * 1赋值运算符的功能以及何时使用它
 * 将已有的对象赋给另一个对象时，将使用重载的赋值运算符：
 * StringBad headline("Hello World!");
 * ...
 * StringBad knot;
 * knot = headline1;
 * 初始化对象时，并不一定会使用赋值运算符：
 * StringBad metoo = knot;//use copy constructor,possibly assignment,too
 * 这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。然而，正如前面指出的，实现时也可能分成两步来处理这条语句
：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而使用=运算符也可能调用赋值运算符。
 *
 *
