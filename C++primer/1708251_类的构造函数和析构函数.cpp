/*类的构造函数和析构函数
应为类提供被称为构造函数和析构函数的标准函数
C++的目标之一是让使用类对象就像用于标准类型一样，然而，到现在为止，本章提供共的代码不能让你像初始化int或结构那样初始化Stcok对象。也就是说，常规的初始化语法不适用于类型Stcok;
int year=2001;
struct thing{
	char* pn;
	int m;
};
thing amabob={"wodget",-23};
Stock hot={"Sukie's Autos,inc.",200,50.25};//这是错误的
不能想上面这样初始化Stock，数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员。因此需要设计合适的成员函数，才能成功地将对象初始化
一般来说，最好是在创建对象时对它进行初始化。例如，请看下面的代码：Stock gift;
gift.buy(10,24.75);
就Stock类当前的实现而言，gift对象的company成员是没有值的。类设计假设用户在调用任何其他成员函数之前调用acquire(),但无法强加这种假设。避开这种问题的方法之一是在创建对象时，自动对它进行初始化。为此，C++提供了一个特殊的成员函数——类构造函数，专门用于构造新对象，将值赋给它们的数据成员。更准确地说，C++为这些成员函数提供了名陈和使用语法，而程序员需要提供方法定义。名称与类名同。

声明和定义构造函数
现在创建Stock的构造函数.由于需要为Stock对象提供3个值，因此应为构造函数提供3个参数
原型如下所示：
Stock::Stock(const string &co,long n=0;double pr=0.0);
{
company=co;
	if(n<0){
		std::cerr<<"Numer of shares can't be negetive;"
				<<company<<" shares set to 0.\n";
		shares=0;
	}
	else
		shares=n;
	shares_val=pr;
	set_tot();
}
使用构造函数
C++提供了两种使用构造函数，第一种是显示第调用构造函数：
Stock food=Stock{"World cabbage",250,1.25};
另一种方式是隐式第调用构造函数：
Stock garment("Furry Mason",50,2.5);
每次创建类对象（甚至使用new动态分配)时，C++都使用类构造函数。下面是将构造函数与new一起使用的方法：
Stock *pstock=new Stock("Electroshock Games",18,19.0);
无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。因此构造函数被用来创建对象，而不能通过调用对象来调用。

默认构造函数
默认构造函数是在为提供显式初始值时，用来创建对象的构造函数。也就是说，它是用于下面这种声明构造函数
Stock fluffy;
这条语句管用的原因在于，如果没有提供任何构造函数，则C++将自动提供默认函数。它是默认构造函数的隐式版本，不做任何工作。对于Stock类来说,默认构造函数可能如下：
Stock::Stock(){}
因此将创建fluffy对象，但不初始化其成员，这和下面的语句创建x，但没有提供值给它一样：
int x;
默认构造函数没有参数，因为声明中不包含值。
奇怪的是，当且进党没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员必须为它提供默认构造函数，如果提供了非默认构造函数，但没有默认构造函数，则下面的声明将出错：
Stock stock1;
这样做的原因可能是想禁止创建未初始化的对象。然而，如果要创建对象，而不显示地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是给已有的共早函数提供默认值
Stock(const string & co="Error",int n=0,double pr=0.0);
另一种是通过函数重载来定义另一个构造函数——一个没有参数的构造函数
Stock();
由于只能有一个默认构造函数——一个没有参数的构造函数：
Stock();
由于只能右一个默认构造函数，因此不要同时采用这两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开就有已知的合理值。因此，用户定义的默认构造函数同城给成员提供隐式初始值。
Stock::Stock(){
	company="no name";
	shares=0;
	share_val=0.0;
	total_val=0.0;
}

Stock first("Concre Conglomerate");//调用非默认构造函数，即接受参数的构造函数
Stock second();//调用一个返回Stock对象的函数
Stock third;//隐式地调用默认构造函数
