/*第九章介绍了全局作用域和局部作用域。可以在全局变量所属文件的任何地方使用它，而局部变量只能在其所属的代码块中使用。函数名称的作用域也可以是全局的，但不能是局部的。C++类引入了一种新的作用域：类作用域
在类中定义的名称（如类数据成员名和类成员函数名）的作用域窦唯整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以子不同类中使用相同的类成员名而不会引起冲突。例如，Stock类的shares成员不同与JobRide类的shares成员。另外，类的作用域移位着不能 从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象：
Stock sleeper("Exclusive Ore",100,0.25);
sleeper.show();
show()//wrong
同样，在定义成员函数时，必须使用作用域解析运算符：
void Stock::update(double price){
}
总之，在类声明或成员函数定义中，可以使用维修是的成员名称，就像sell()调用set_tot()成员函数时那样。构造函数名称在被调用时，才能被识别，因为它的名称与类名相同，在其他情况下，使用类成员名时，必须根据上下文使用成员运算符(.)、->,::
例如，下面代码演示了如何访问具有类作用域的标识符：
class Ik{
private:
	int fuse;
public:
	IK(int f=9){fuss=f;}
	void View() const;
};
void Ik::VireIk() const
{
	cout<<fuss<<endl;
}
...
int main(){
	Ik *pik=new Ik;
	Ik ee=Ik(8);
	ee.ViewIk();
	pik->ViewIk();
	...
}
作用域为类的常量
有时候，使用符号常量的作用域为类很有用.例如，类声明可能使用字面值30来制定数组的长度，由于该常量对于所有对象来说都是相同的，因此创建一个由所有对象共享的常量是个不错的注意。您可能一味这样做客行
class Bakery
{
private:
	const int Months=12;
	double costs[Months];
}
但这是行不通的，因为声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，将没有用于存储值的空间。然而，右两种方式可以实现这个目标，并且效果相同
第一种方式是在类声明中声明一个枚举，在类声明中声明枚举的作用于为整个类，因此可以用枚举为整型常量提供作用于为整个类的符号名称，也就是说，可以这样可是Bakery声明：
class Bakery
{
private:
	enum{Months=12};
	double costs[Months];
	...}
注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。另外，Months知识一个符号名称，在作用域为整个类的代码中遇到它时，编译器将用30来代替它。
C++提供了另一种在类中定义常量的方式——使用关键字static:
class Bakery
{
private:
	static const int Months=12;
	double costs[Months];
	...
}
这里将创建一个名为Months的常量，该常量将于其他静态变量存储在一起，而不是存储在对象中，因此，只有一个Months常量，被所有Bakery对象共享。
