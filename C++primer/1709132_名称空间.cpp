/*在C++中，名称可以是变量、函数、结构、名称、枚举以及类和结构的成员。当随着项目的增大，名称相互冲突的可能性也增加。
 * C++编程提供了名称空间工具，以便更好地控制名称的作用域。经过了一段时间时间后，编译器才支持名称空间,但现在这种支持很普遍
 * 传统的C++命名空间
 *
 * 1声明区域。声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块
 * 2潜在作用域。变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明作用域小，这是由于变量必须定义后才能使用
 *
 * 新的名称空间特性
 * C++中新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时与徐程序的其他部分使用该名称空间中声明的东西
 *
 * 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的
 * 名称空间是开放的，即可以把名称加入到已有的名称空间中。
 *
 * namespace Jill{
 *	   char * goose(const char*);
 *	}
 *
 *	当然能需要由一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析运算符::,使用名称空间来限定该名称:
 *	Jack::pai=12.34;
 *	Jill::Hill mole;
 *	Jack::fetch();
 *
 *	1using声明和using编译指令
 *	using 声明使特定的标识符可用，using编译指令使整个名称空间可用
 *
 *	using声明由限定的名称和它前面的关键字using组成：
 *	using Jill::fetch();
 *	using声明将特定的名声添加到它所属的声明区域中。
 *	namespace Jill{
 *		double bucket(double n){...}
 *		double fetch;
 *		struct hill{};
 *	}
 *	char fetch;
 *	int main(){
 *		uding Jill::fetch;
 *		double fetch;//wrong!
 *		cin>>fetch;
 *		cin>>::fetch;
 *		...
 *	}
 *
 *
 *	using声明使一个名称可用，而using编译指令使所有的名称都可用，using编译指令由名称 空间名和它的前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：
 *
 *
