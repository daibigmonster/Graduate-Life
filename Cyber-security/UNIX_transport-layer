TCP传输控制协议。TCP是一个面向连接的协议，为用户进程提供可靠的全双供字节流，TCP套接字是一种流套接字。TCP关心确认、超时和重传之类的细节。大多数因特网应用程序使用TCP。
UDP 用户数据报协议。UDP是一个无连接协议。UDP套接字是一种数据包套接字。UDP数据包不能保证最终到达它们的目的地
SCTP 流控制传输协议。SCTP是一个提供可靠全双工关联的面向连接的协议，我们使用“关联”一词来指称SCTP中的连接。因为SCTP是多宿的，从而每个关联的两端均设计一组IP地址和一个端口号。SCTP提供消息服务，也就是维护来自应用层的记录边界。
ICMP 网际控制消息协议。ICMP处理在路由器和主机之间爱呢流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件本身（而不是用户进程）产生和处理。
ARP 地址解析协议。ARP把一个IPv4地址映射称一个硬件地址（如以太网地址）。ARP通常用于诸如以太网、令牌环网和FDDI等广播网络，在点到点的网络并不需要。
DLPI 数据链路层提供者接口，该接口也提供对于数据链路层的访问能力

TCP含有用于动态股端客户和服务器之间的往返时间的算法，以便直到它直到等待一个确认需要多少时间。

SCTP中使用关联一词取代连接是为了避免这样的内涵：一个连接只设计两个IP地址之间的通信。一个关联指代两个系统之间的一次通信。它可能因为SCTP支持多宿而设计不止两个地址。

与TCP不同的是，SCTP是面向消息的。它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每条记录的长度随数据一道传递给接收端应用。SCTP能够在所连接的断电之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的消失不会阻塞统一关联其他流上消息的传递。这种做法与TCp正好相反，就TCP而言，在单一字节流中任何位置的字节丢失都将阻塞连接上其后所有数据的递送，直到该丢失被修复为止。

TCP连接的建立和终止
帮助大家理解connect、accept和close
三路握手
建立一个TCP会发生下述情形
1服务器必须准备好接受外来的连接。这通常通过调用socket、bing和listen这3个函数来完成。我们称之为被动打开。
2客户tongue调用connect发起主动打开。这导致客户TCP发送一个SYN（同步）分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据包只含有一个IP首部、一个TCP首部及可能有的TCP选项
3服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK
4客户必须确认服务器的SYN
TCP选项
每一个SYN可以含有多个TCP现象。下面是常用的TCP选项
MSS选项。发送SYN的TCP一端使用本项通告对端它的最大分节的大小即MSS，也就是它在本连接的每个TCP分节的最大大小
窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535,因为在TCP首部中相应的字段占16位
时间戳选项。这个选项对于高速网络连接是必要的，它可以防止失而复现的分组可能造成的数据损坏。
TCP连接终止
TCP建立一个连接需要3个分节，终止一个需要4个分节
一旦建立一个连接，客户就构造一个请求并发送给服务器。这里我们假设该请求适合于单个TCP分节（即请求大小小于服务器通告的1460字节的MSS）。服务器处理该请求并发送一个应答，我们假设该应答也适合于单个分节（本例即小于536字节）。图中使用粗箭头表示这两个数据分节。注意，服务器对客户请求的确认是伴随其应答发送的。这种做法称为捎带，它通常在服务器处理请求并产生应答的时间少于200ms产生。如果服务器耗用更长时间，譬如说1s，那么我们看到的是先确认后应答。
图中随后展示的是终止连接的4个分节，注意，执行主动关闭的那一端进入哦我们将在下一节讨论的TIME_WAIT状态
如果该连接的整个目的仅仅是发送一个单分节的请求和接收一个单分节的应答，那么使用TCP由8个分节的开销。如果改用UDP，那么只需交换两个分组：一个承载请求，一个承载应答。然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆写接送传输层（TCP）转移到UDP应用进程。TCP提供的另一个重要特性即拥塞控制也必须由UDP进程来处理。尽管如此，我们仍然需要直到许多网络应用是使用UDP构建的，因为它们需要交换的数据量较少，而UDP避免了TCP连接建立和终止所需的开销。

TIME_WAIT状态
TCP中有关网络最不容易理解的是它的TIME_WAIT状态。我们看到执行主动关闭那端经历了这个状态。这端点停留在这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL.
任何TCP实现都必须为MSL选择一个值。TIME_WAIT状态持续时间在1分钟到4分钟之间。MSL是任何IP数据报能够在因特网中存活的最长时间。我们直到这个时间是有限的，因为每个数据包含有一个跳限的8位字段，它的最大值为255.尽管这是一个跳数限制而不是真正的时间限制，我们仍然假设：具有最大跳限（255）的分组在网络中存在的时间不可能超过MSL秒。
分组在网络中“迷途”通常是路由异常的结果。某个路由崩溃或某两个路由器之间的某个链路断开时，路由协议需花费数秒钟到数分钟的时间才能稳定并找出另外一条通路。在这段时间内有可能发生路由循环，我们关心的分组就可能陷入这样的循环。假设迷途的分组是一个TCP分节，在它迷途期间，发送端TCP超时并重传该分组，而重传的分组却通过某条候选路径到达最终目的地。然而不仅后（自迷途的分组开始其旅程起最多MSL秒以内）路由循环修复，早先迷失在这个循环的分组最终也被送到目的地。这个原来的分组被称为迷途的重复分组或漫游的重复分组。TCP必须正确处理这些重复的分组。
TIME_WAIT状态有两个存在的理由
1可靠地实现TCP全双工连接的终止;
2允许老的重复分节在网络中消逝。
第一个理由可以通过查看图 并假设最终的ACk丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应一个RST（另外一种类型的TCP分节），该分节被服务器解释成一个错误。如果TCP打算执行所有必要的所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节任何一个分节丢失的情况。本例子也说明了为什么执行主动关闭的那一端是处于TIME_WAIT状态的那一端：因为可能不得不重传最终那个ACK的就是那一端。
为理解在TIME——WAIT状态的第二个理由，我们假设在12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。我们关闭这个连接，过一段时间后在相同的IP地址和端口之间建立另一个连接。后一个连接称为前一个连接的化身，因为它们的IP地址和端口号都相同。TCP必须防止来自某个连接的老的重复分组在该连接终止后再现，从而被误解成属于同一个连接的某个新的化身。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再现，从而被误解成同一个连接的某个新的化身。未做到这一点，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已经在网络中消逝了。

2.8SCTP关联的建立和终止
四路握手
1服务器必须准备好接受外来的关联。
2客户通过调用connect或者发送一个隐式打开该关联的消息进行主动打开。这使得客户SCTP发送一个INIT消息，该消息告诉服务器客户的IP地址清单、初始序列号、用于标识本关联中所有分组的起始标记、客户请求的外出流的数目以及客户能够支持的外来流的数目。
3服务器以一个INIt ACK 消息确认客户的INIT消息，其中含有服务器的IP地址清单、初始序列号、起始标记、服务器请求的外出流的数目以及一个状态cookie.cookie包含服务器用于确信本馆连有效所需的所有状态，它是数字化签名过的，以确保其有效性。
四路握手过程结束时，两端各自选择一个目的的地址。当不存在网络故障时，主目的地址将用足数据返送到到的默认目的地。
SCTP中使用四路我收是为了避免一种将在4.5节讨论的拒绝服务攻击。

SCTP不像TCP那样允许“半关闭”的关联。当一端关闭某个关联时，另一端必须停止发送新的数据。关联关闭请求的接收端发送完已经排队的数据（如果有的话）后，完成关联的关闭

SCTP状态转换图
本状态机中从一个状态到另一个状态的转换有SCTP规则基于当前状态及在该状态下锁接收的块规定。举例，当某个应用进程在CLOSED状态下执行主动打开时，SCTP将发送一个INIT，且新的状态是COOKIE-WAIT。如果这个SCTO接着接收到一个INIT ACK，它将发送一个COOKIE ECHO，且新的状态是COOKIE-ECHOED。如果该SCTP随后接收带一个COOKIE ACK，它将装换成ESTABLISHED状态。这个状态是绝大多数数据传送发生点的状态，尽管DATA块也可有有COOKIE ECHO块或COOKIE ACK块所在的消息捆绑捎带。

SCTP使用参数和块方便增设可选特性。新的特性通过添加这两个条目之一加以定义，并允许通常的SCTP处理规则回报未知的参数和未知的块。参数类型字段和块类型字段的高两位指明SCTP接收端该如何处置位置的参数或未知的块。

端口号
任何时候，多个进程可能同时使用TCP、UDP和SCTP这3中传输层协议中的任何一种。这3种协议都是用16位整数的端口号来区分这些进程。
当一个客户想要跟一个服务器联系时，它必须标识想要与之通信的这个服务器。TCP、UDP和SCTP定义了一组众所周知的端口，用于标识众所周知的服务。
另一方面，客户通常使用短期存活的临时端口。这些端口号通常由传输层协议自动赋予客户。客户不关心其临时端口的具体值，而只需确信该端口在所在主机中是唯一的就行。

IANA（因特网已分配数值权威机构）维护着一个端口分配状况的清单
端口号被分为一下3段
1众所周知的端口1-1023，如果可能的话，相同的端口号就分配给TCP、UDP和SCTP的同一给定服务。
2已登记的端口为1024-49151.这些端口不受IANA控制，不过由IANNA登记并提供它们的使用情况清单，以方便整个群体。
3，49152-65535是动态的或私用的端口。IANA不管这些端口。它们就是我们所称的临时端口


套接字对
一个TCP连接的套接字对视一个定义该连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。就SCTP来说，一个锻炼由一组本地IP地址、一个本地端口、一组外地IP地址、一个外地端口标识。在两个端点均非多宿这一简单的情形下，SCTP与TCP所用的四元组套接字对一致。然而在某个关联的任何一个端点为多宿的情形下，同一个关联可能需要多个四元组标识（这些四元组的IP地址各不相同，但端口号是一样的）
标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。
我们可以把套接字对的概念扩展到UDP，即使UDP是无连接的。当讲解套接字函数（bind、connect、getpeername等）时，我们将指明它们在制定套接字对中的哪些值。举例来说，bind函数要求应用程序给TCp、UDP或SCTP套接字指定本地IP地址和本地端口号。

TCP端口号与并发服务器
并发服务器中主服务器循环通过派生一个子进程来处理每一个新的连接。如果子进程继续使用众所周知的端口来服务一个长时间的请求，那将会发生什么？让我们来看一个典型的序列
。。。。
我们使用记号（*:21,*:*）指出服务器套接字对。服务器在任意本地端口（第一个星号）的端口21上等待连接请求。外地IP地址和外地端口都没有指定，我们用“*.*”来表示。我们称它位监听套接字.

这里指定本地IP地址的星号为通配符。如果服务其的主机是多宿的，服务器可以指定它只接受到达某个特定本地接口的外来连接。这里要么选选一个接口要么选任意接口。服务器不能指定一个个包含多个地址的清单。通配的本地地址表示“任意”这个选择。在图1-9中，通配地址通过在调用bind之前把套接字地址结构中的IP地址字段设置成INADDR_ANY来指定
稍后在IP地址为206.168.112.219的主机上启动第一个客户，它对服务器IP地址之一12.106.32.254执行主动打开。我们假设本例中客户主机的TCP选择的临时端口位1500，途中在客户的下方标出了它的套接字对。
荡妇武器接收并接受这个客户的连接时，它fork一个自身的副本，让子进程来处理该客户的请求，
至此，我们必须在服务器主机上区分监听套接字和已连接套接字。注意已连接套接字使用与监听套接字相同的本地接口（21）。还要注意在多宿的服务器主机上，连接一旦建立，已连接套接字本地地址（12.106.32.254）随即填入。
下一步我们假设在客户主机上另有一个客户请求连接到同一个服务器。客户主机的TCP位这个新客户的套接字分配一个位使用的临时端口，譬如说1501。服务器上这两个连接是有区别的：第一个连接的套接字对和第二个连接的套接字对不一样，因为客户的TCP端给第二个连接选择了一个未使用的短口（1501）
应注意，TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点收到某个到达的分节。如图中对于同一个本地端口（21）存在3个套接字。如果一个分节来自206.168.112.219端口1500,目的位12.106.32.254端口21,它就被传递给第二个子进程。所有目的端口位21的其它TCP分节都被递送给拥有监听套接字的最初那个服务器（父进程）。

缓冲区大小及限制
下面我们将介绍一些影响IP数据包大小的限制。我们先介绍这些限制，然后就它们如何影响应用进程能够传送的数据进行综合分析。
IP4数据报的最大大小是65535字节，包括IP4首部。这是因为其总长度字段占据16位。
IP6数据报的最大大小是65575字节，包括40字节的IP6首部。这是因为其静荷长度字段占据16位。注意IP6的静荷长度字段不包括IP6的首部，而IP4的总长度字段包括IP4首部。
MTU（最大传输单元）
许多网络有一个可由硬件规定的MTU。举例来说，以太网的MTU是1500字节。另有一些链路（例如使用PPP协议的点到点链路）其MTU可以认为配置。较老的SLIP链路通常使用1006字节或296字节的MTU
IP4要求的最小链路MTU是68字节。这允许最大的IP4首部（包括20字节的固定长度部分和最多40字节的选项部分）拼接最小的片段（IP4首部中片段偏移字段以8个字节为单位）IP6要求的最小链路MTU位1280字节。IP6可以运行在MTU小于此最小值的链路上，不过需要特定于链路的分片和重组功能，以使得这些链路看起来具有至少位1280字节的MTU。
在两个主机之间最小的MTU称为路径MTU。1500字节的以太网MTU是当今常见的路径MTU。两个主机之间相反的两个方向上路径MTU可以不一致，因为在因特网路由选择往往是不对称的，也就是说从A到B的路径与从B到A的路径可以不同
当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IP4和IP6都将执行分片。这些分片在到达最终目的地之前通常不会被重组。IP4主机对其产生的数据报执行分片，IP4路由器则对其转发的数据报执行分片。然而IP6只有主机对其产生的数据报分片，IP6路由器不对其转发的数据包执行分片。

IP4首部部分片位（即DF位）若被设置，那么不管是发送这些数据报的主机还是转发它们的路由器，都不允许对它们分片。当路由器接收到一个超过其MTU大小且设置了DF位的IP4数据报时，它将产生ICMP4（目的地不可达，需分片但DF位已设置）出错信息

既然IP6路由器不执行分片，每个IP6数据报是一拿哈尼一个DF位。当路由器接收到超过其外出链路MTU大小的IP6数据报时，它将产生ICMP6（分组太大）出错信息

路径MTU发现对于IP4是可选的，然而IP6的所有实现要么必须支持它，要么必须总是使用最小的MTU发送IP6数据报。

IP4和IP6都定义了最小重组缓冲区大小，它是IP4或IP6的任何实现都必须保证支持的最小数据报大小，其值对于IP4为576字节，对IP6为1500字节。例如，对于IP4,我们不能判定某个给定目的地能否接受577字节的数据报。为此有许多使用UDP的IP4网络应用（DNS、RIP、TFTP、BOOTP、SNMP）避免产生大于这个大小的数据报
TCP有一个MSS（最大分节大小），用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。在前面我们看到过SYN分节上的MSS选项。MSS的目的是告诉对端其重组缓冲区大小的实际值，从而使图避免分片。MSS经常设置成MTU减去IP和TCP首部的固定长度。在以太网中使用IP4的MSS值是1460,使用IP6的MSS值位1440.在TCP的MSS选项中，MSS值是一个16位的字段，限定其最大值位65535.这对于IP4是适合的，因为IP4的数据报中最大TCP数据量位65495（65535减去IP4首部的20字节和TCP首部的20字节）然而对于IP6,确需要使用另外一种技巧。首先，没有最大静荷选项的IP6数据报中最大TCP数据量位65515（65535减去CP首部的20字节）。65535这个MSS值于是被市委表示“无限”的一个特殊值。该值只有在用大特大净荷选项是才是用，不过这种情况却要求实际的MTU超过65535.其次，如果TCP使用最大净荷选项，并且收到的对端通告的MSS为65535,那么它所发送数据包的大小限制就是接口MTU。如果这个值太大（也就是说所在路径中某个链路的MTU比较小），那么路径MTU发现功能将确定这个最小值。
SCTP基于到对端所有地址发现的最小路径MTU保持一个片点。这个最小MTU大小用于把较大的用户信息分割成较小的能够以单个IP数据包发送的若干片段。SCTP_MAXSEG套接字选项可以影响该值，使得用户能够请求一个更小的分片点。

TCP输出
如图展示了某个应用进程写数据到了一个TCP套接字中时发生的步骤。
每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调write时，内核从应用进程的缓冲区中复制所有数据到套接字发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据（或是应用进程的缓冲区大于套接字的发送，或是套接字的发送缓冲区已经有其它数据），该应用进程将被投入睡眠。这里假设套接字是阻塞的，它是通常的默认设置。内核将不从write系统调用返回，知道应用进程缓冲区的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已经接收到了数据。
这一端的TCO提取套接字发送缓冲区中的数据并把它发送给对端TCP，其过程基于TCP数据传送的所有规则。对端TCP必须确认接收到的数据，伴随来自对端的ACK不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为一发送的数据保留一个副本，知道它被对端确认为止。
本端TCP以MSS大小或更小块把数据传递给IP，同时给每个数据块安上一个TCP首部以构成TCP分节，其中MSS或是由对端通告的值，或是536（536是IP4最小重组缓冲区字节数576减去IP4首部字节数20字节和TCP首部字节数20的结果）。IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。IP可能再把数据报传递给数据链路之前将其分片，不过我们已经谈到MSS选项的目的之一就是试图避免分片，较新的实现还使用了路径MTU发现功能。每个数据链路都有一个输出队列，如果该队列已满，那么信道的数据将被丢弃

既然UDP是不可靠的，它不必保存应用进程的一个副本，因此无需一个真正的数据缓冲区

