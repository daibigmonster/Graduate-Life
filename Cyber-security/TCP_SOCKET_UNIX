本章讲解编写一个完整的TCP客户/服务器程序所需要的基本套接字函数。讲解完即将使用的所有套接字函数之后，我们就在下一张中开发这个客户/服务器程序。我们将围绕该客户/服务器程序展开本书，并多次对它加以改进
我们还讲解并发服务器，它是在同时有大量客户连接到同一服务器上时用于提供并发性的一种常用Unix技术。每个客户连接都迫使服务器为它派生（fork）一个新的进程。
图4-1在给出了在一对TCP客户与服务器进程之间发生的一些典型时间的时间表，服务器首先驱动，稍后某个时刻客户启动，它试图连接到服务器。我们假设客户给服务器发送一个请求，服务器处理该请求，并给客户发回一个响应。这个过程一直持续下去，直到客户关闭连接的客户端，从而给服务器发送一个EOF（文件结束）。服务器接着也关闭连接的服务器端，然后结束运行或等待新的客户连接。

socket函数
为了执行网络I/O，一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型（使用IP4的TCP，使用IP6的UDP，Unix域字节流协议等）。
#include<sys/socket.h>
int socket(int family,int type,int protocol);
其中family参数指明协议族，它是图4-2中所示的某个常值。该参数也往往被称为协议域。type参数指明套接字类型，它是图4-3中所示的某个常值。protocol参数应设为图4-4所示的某个协议类型的常值，或者设为0,以选择给定family和同一片额组合的系统默认值。
并非所有套接字family与type组合都是有效的，图4-5给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但是还没有找到便捷的省略词。而空白组合项是无效的。

AF_INET IP4协议
AF_INET6 IP6协议
AF_LOCAL Unix域协议
AF_ROUTE 路由套接字
AF_KEY 密钥套接字
SOCK_STREAM 字节流套接字
SOCK_DRGAM 数据报套接字
SOCK_SEQPACKET 有序分组套接字
SOCK_RAW 原始套接字

IPPROTO_CP TCP传输协议
IPPROTO_UDP UDP传输协议
IPPROTO_SCTP SCTP传输协议
socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符，简称是sockfd。为了得到这个套接字描述符，我们只是指定了协议族和套接字类型（字节流、数据包或原始套接字）。我们并没有指定本地协议地址或远程协议地址。
对比AF_XXX和PF_XXX
AF_前缀表示地址族，PF_前缀表示协议族。历史上曾有这样的想法：单个协议族可以支持多个地址族，PF_值用来创建套接字，而AF_值用于套接字地址结构。但实际上，支持多个地址族的协议族从来就没有出现过，而且头文件<sys/socket.h>中为一给定协议定义PF_值总是与此协议的AF_值相等。尽管这种相等关系并不一定永远成立，但是若有人试图给已有的协议改变这种约定，则许多显存代码都将崩溃。为与显存代码保持一致，本书中我们仅使用AF_常值，尽管（主要是）在调用socket时我们可能会碰到PF_值。

connect函数
TCP客户用connect函数来建立与TCP服务器的连接
#include<sys/socket.h>
int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen);
sockfd是socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。如3.3节所述。套接字地址结构必须含有服务器的IP地址和端口号。
客户在调用函数conncet前不必非得调用
