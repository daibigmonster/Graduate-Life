/*题目：输入两个链表，找出它们的第一个公共结点。链表结点的定义如下：
struct ListNode
{
    int m_nKey;
    ListNode* m_pNext;
}
从链表结点的定义可以看出，这两个链表是单向链表。如果两个单向链表由公共的结点，那么这两个链表从某一个结点开始，它们的m_pNext都指向同一个结点。但由于是单向链表的结点，每个结只有一个m_pNext，因此从第一个公共结点开始，之后它们所有将诶点都是从何，不可能出现分叉。
经过分析我们发现，如果两个链表由公共结点，那么公共结点出现在两个链表的尾部。如果我们从尾部开始往前比较，最后一个相容的结点就是我们要找的结点。可问题是在单向链表中，我们只能从头结点开始顺序遍历，最后才能到达尾结点。最后到达的尾结点却要最先被比较，于是我们就能两道用栈的特点来解决这个问题：分别把这两个链表的结点方式两个栈里，这样两个链表的尾结点久违与两个栈的栈顶，接下来比较两个栈顶的定点是否相同。如果相同，则把栈顶弹出记者比较下一个栈顶，直到找到最后一个相同的结点。
更简单的方法，：首先比例两个链表得到它们的长度，就能直到哪个链表比较长以及长的链表链表比短的链表多几个结点。在第二次遍历的时候，在较长的林彪上先走若干不，接着再同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共点。
