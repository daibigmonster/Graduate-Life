/* 上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题“状态”，这个状态是怎么找出来的呢？根据子问题定义的状态。逆找到子问题，状态也就浮出水面了。最终我们要求的解的问题，可以用这个状态来表示：d(11)，即凑够11源最少需要多少个硬币。那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i),上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1,d(3-3)+1}。没错，它就是状态转移方程，描述状态之间如何转移的。当然我们要对它抽象一下，
d(i)=min{d(i-vj)+1},其中i-vj>=0,vj表示第j个硬币的面值;
*/
int mian(){
    int a[3]={1,3,5},sum=11,cent=0,dp[12];
    for(int i=0;i<=sum;i++)dp[i]=i;
    for(int i=1;i<=sum;++i){
        for(int j=0;j<3;j++){
            if(i>=a[j]&&dp[i-a[j]]+1<dp[i])
                dp[i]=dp[i-a[j]]+1;
        }
    }
    cout<<dp[sum]<<endl;
    return 0;
}
/*
将一个由N行数字组成的三角形，如图所以，设计一个算法，计算出三角形的由顶至底的一条路径，使该路径经过的数字总和最大。
*/
int main()
{
    int t,n,i,j;
    for(i=n-1;i;--i)
        for(j=0;j<i;j++)
            a[i-1][j]+=max(a[i][j],a[i][j+1]);
    cout<<a[0][0]<<endl;
    return 0;
}
/*一个序列有N个数，A1，A2,...,AN,求出最长非降子序列的长度
面对这样一个问题，我们首先要定义
